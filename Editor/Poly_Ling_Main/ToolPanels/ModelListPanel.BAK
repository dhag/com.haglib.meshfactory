// Assets/Editor/Poly_Ling_/ToolPanels/MQO/Export/MQOPartialExportPanel.cs
// MQO部分エクスポートパネル
// 左リスト（モデル側）と右リスト（MQO側）でチェックを入れ、チェック順に対応付けてエクスポート

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using Poly_Ling.Data;
using Poly_Ling.Model;
using Poly_Ling.Localization;
using Poly_Ling.Tools;
using Poly_Ling.PMX;

namespace Poly_Ling.MQO
{
    /// <summary>
    /// MQO部分エクスポートパネル
    /// </summary>
    public class MQOPartialExportPanel : EditorWindow
    {
        // ================================================================
        // ローカライズ辞書
        // ================================================================

        private static readonly Dictionary<string, Dictionary<string, string>> _localize = new()
        {
            ["WindowTitle"] = new() { ["en"] = "MQO Partial Export", ["ja"] = "MQO部分エクスポート" },

            // セクション
            ["ReferenceMQO"] = new() { ["en"] = "Reference MQO", ["ja"] = "リファレンスMQO" },
            ["Options"] = new() { ["en"] = "Options", ["ja"] = "オプション" },
            ["ModelMeshes"] = new() { ["en"] = "Model Meshes", ["ja"] = "モデルメッシュ" },
            ["MQOObjects"] = new() { ["en"] = "MQO Objects", ["ja"] = "MQOオブジェクト" },

            // ラベル
            ["MQOFile"] = new() { ["en"] = "MQO File", ["ja"] = "MQOファイル" },
            ["Expanded"] = new() { ["en"] = "Model Expanded", ["ja"] = "モデル展開済み" },
            ["Scale"] = new() { ["en"] = "Scale", ["ja"] = "スケール" },
            ["FlipZ"] = new() { ["en"] = "Flip Z", ["ja"] = "Z反転" },
            ["SkipBakedMirror"] = new() { ["en"] = "Skip Baked Mirror (flag only)", ["ja"] = "ベイクミラーをスキップ（フラグのみ）" },

            // WriteBackオプション
            ["WriteBack"] = new() { ["en"] = "WriteBack Options", ["ja"] = "書き戻しオプション" },
            ["WriteBackPosition"] = new() { ["en"] = "Position", ["ja"] = "位置" },
            ["WriteBackUV"] = new() { ["en"] = "UV", ["ja"] = "UV" },
            ["WriteBackBoneWeight"] = new() { ["en"] = "BoneWeight", ["ja"] = "ボーンウェイト" },

            // ボタン
            ["SelectAll"] = new() { ["en"] = "All", ["ja"] = "全選択" },
            ["SelectNone"] = new() { ["en"] = "None", ["ja"] = "全解除" },
            ["Export"] = new() { ["en"] = "Export MQO", ["ja"] = "MQOエクスポート" },

            // ステータス
            ["Selection"] = new() { ["en"] = "Selection: Model {0} ↔ MQO {1}", ["ja"] = "選択: モデル {0} ↔ MQO {1}" },
            ["CountMismatch"] = new() { ["en"] = "Count mismatch!", ["ja"] = "数が不一致！" },
            ["Ready"] = new() { ["en"] = "Ready to export", ["ja"] = "エクスポート可能" },

            // メッセージ
            ["NoContext"] = new() { ["en"] = "No context. Open from Poly_Ling.", ["ja"] = "コンテキスト未設定" },
            ["NoModel"] = new() { ["en"] = "No model loaded", ["ja"] = "モデルなし" },
            ["SelectMQOFirst"] = new() { ["en"] = "Select MQO file", ["ja"] = "MQOファイルを選択" },
            ["ExportSuccess"] = new() { ["en"] = "Export: {0}", ["ja"] = "エクスポート完了: {0}" },
            ["ExportFailed"] = new() { ["en"] = "Export failed: {0}", ["ja"] = "エクスポート失敗: {0}" },
            ["VertexMismatch"] = new() { ["en"] = "Vertex mismatch: {0}({1}) → {2}({3})", ["ja"] = "頂点数不一致: {0}({1}) → {2}({3})" },
        };

        private static string T(string key) => L.GetFrom(_localize, key);
        private static string T(string key, params object[] args) => L.GetFrom(_localize, key, args);

        // ================================================================
        // フィールド
        // ================================================================

        private ToolContext _context;
        private string _mqoFilePath = "";
        private MQODocument _mqoDocument;

        // モデル側リスト
        private List<MeshEntry> _modelMeshes = new List<MeshEntry>();

        // MQO側リスト
        private List<MQOEntry> _mqoObjects = new List<MQOEntry>();

        // MQOインポート結果（展開後頂点数計算用）
        private MQOImportResult _mqoImportResult;

        // オプション
        // PMXは展開後の値しか得られない
        private float _scale = 10f;
        private bool _flipZ = true;
        private bool _skipBakedMirror = true;

        // WriteBackオプション
        private bool _writeBackPosition = true;
        private bool _writeBackUV = false;
        private bool _writeBackBoneWeight = false;

        // UI状態
        private Vector2 _scrollLeft;
        private Vector2 _scrollRight;
        private string _lastResult = "";

        // ================================================================
        // データクラス
        // ================================================================

        private class MeshEntry
        {
            public bool Selected;
            public int Index;              // DrawableMeshes内のインデックス
            public string Name;
            public int VertexCount;        // 生頂点数
            public int ExpandedVertexCount; // 展開後頂点数
            public bool IsBakedMirror;
            public MeshContext Context;
            public HashSet<int> IsolatedVertices;
        }

        private class MQOEntry
        {
            public bool Selected;
            public int Index;              // MQODocument.Objects内のインデックス
            public string Name;
            public int VertexCount;        // 生頂点数
            public int ExpandedVertexCount; // 展開後頂点数
            public MeshContext MeshContext; // インポート結果のMeshContext
        }

        // ================================================================
        // プロパティ
        // ================================================================

        private ModelContext Model => _context?.Model;

        // ================================================================
        // Open
        // ================================================================

        [MenuItem("Tools/Poly_Ling/MQO Partial Export")]
        public static void ShowWindow()
        {
            var panel = GetWindow<MQOPartialExportPanel>();
            panel.titleContent = new GUIContent(T("WindowTitle"));
            panel.minSize = new Vector2(700, 500);
            panel.Show();
        }

        public static void Open(ToolContext ctx)
        {
            var panel = GetWindow<MQOPartialExportPanel>();
            panel.titleContent = new GUIContent(T("WindowTitle"));
            panel.minSize = new Vector2(700, 500);
            panel._context = ctx;
            panel.BuildModelList();
            panel.Show();
        }

        public void SetContext(ToolContext ctx)
        {
            _context = ctx;
            BuildModelList();
            if (_mqoDocument != null)
            {
                AutoMatch();
            }
        }

        // ================================================================
        // GUI
        // ================================================================

        private void OnGUI()
        {
            // MQOファイル選択
            DrawMQOFileSection();
            EditorGUILayout.Space(5);

            // オプション
            DrawOptionsSection();
            EditorGUILayout.Space(5);

            // 左右リスト
            DrawDualListSection();
            EditorGUILayout.Space(5);

            // ステータスとエクスポート
            DrawExportSection();
        }

        // ================================================================
        // MQOファイルセクション
        // ================================================================

        private void DrawMQOFileSection()
        {
            EditorGUILayout.LabelField(T("ReferenceMQO"), EditorStyles.boldLabel);

            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.PrefixLabel(T("MQOFile"));
                var rect = GUILayoutUtility.GetRect(GUIContent.none, EditorStyles.textField, GUILayout.ExpandWidth(true));
                _mqoFilePath = EditorGUI.TextField(rect, _mqoFilePath);

                HandleDropOnRect(rect, ".mqo", path =>
                {
                    _mqoFilePath = path;
                    LoadMQOAndMatch();
                });

                if (GUILayout.Button("...", GUILayout.Width(30)))
                {
                    string dir = string.IsNullOrEmpty(_mqoFilePath) ? Application.dataPath : Path.GetDirectoryName(_mqoFilePath);
                    string path = EditorUtility.OpenFilePanel("Select MQO", dir, "mqo");
                    if (!string.IsNullOrEmpty(path))
                    {
                        _mqoFilePath = path;
                        LoadMQOAndMatch();
                    }
                }
            }

            if (_mqoDocument != null)
            {
                int nonEmpty = _mqoObjects.Count;
                int total = _mqoDocument.Objects.Count;
                EditorGUILayout.LabelField($"Objects: {nonEmpty} / {total}", EditorStyles.miniLabel);
            }
        }

        // ================================================================
        // オプションセクション
        // ================================================================

        private void DrawOptionsSection()
        {
            EditorGUILayout.LabelField(T("Options"), EditorStyles.boldLabel);

            using (new EditorGUILayout.HorizontalScope())
            {
                _scale = EditorGUILayout.FloatField(T("Scale"), _scale, GUILayout.Width(150));
                _flipZ = EditorGUILayout.ToggleLeft(T("FlipZ"), _flipZ, GUILayout.Width(80));
            }

            bool prevSkip = _skipBakedMirror;
            _skipBakedMirror = EditorGUILayout.ToggleLeft(T("SkipBakedMirror"), _skipBakedMirror);
            if (prevSkip != _skipBakedMirror)
            {
                BuildModelList();
                if (_mqoDocument != null) AutoMatch();
            }

            // WriteBackオプション
            EditorGUILayout.Space(5);
            EditorGUILayout.LabelField(T("WriteBack"), EditorStyles.boldLabel);
            using (new EditorGUILayout.HorizontalScope())
            {
                _writeBackPosition = EditorGUILayout.ToggleLeft(T("WriteBackPosition"), _writeBackPosition, GUILayout.Width(100));
                _writeBackUV = EditorGUILayout.ToggleLeft(T("WriteBackUV"), _writeBackUV, GUILayout.Width(80));
                _writeBackBoneWeight = EditorGUILayout.ToggleLeft(T("WriteBackBoneWeight"), _writeBackBoneWeight, GUILayout.Width(140));
            }
        }

        // ================================================================
        // 左右リストセクション
        // ================================================================

        private void DrawDualListSection()
        {
            if (_context == null)
            {
                EditorGUILayout.HelpBox(T("NoContext"), MessageType.Warning);
                return;
            }
            if (Model == null)
            {
                EditorGUILayout.HelpBox(T("NoModel"), MessageType.Warning);
                return;
            }
            if (_mqoDocument == null)
            {
                EditorGUILayout.HelpBox(T("SelectMQOFirst"), MessageType.Info);
                return;
            }

            float halfWidth = (position.width - 30) / 2;

            using (new EditorGUILayout.HorizontalScope())
            {
                // 左リスト（モデル側）
                using (new EditorGUILayout.VerticalScope(GUILayout.Width(halfWidth)))
                {
                    DrawListHeader(T("ModelMeshes"), _modelMeshes, true);
                    _scrollLeft = EditorGUILayout.BeginScrollView(_scrollLeft, GUILayout.Height(300));
                    DrawModelList();
                    EditorGUILayout.EndScrollView();
                }

                // 右リスト（MQO側）
                using (new EditorGUILayout.VerticalScope(GUILayout.Width(halfWidth)))
                {
                    DrawListHeader(T("MQOObjects"), _mqoObjects, false);
                    _scrollRight = EditorGUILayout.BeginScrollView(_scrollRight, GUILayout.Height(300));
                    DrawMQOList();
                    EditorGUILayout.EndScrollView();
                }
            }
        }

        private void DrawListHeader<TEntry>(string title, List<TEntry> list, bool isModel)
        {
            using (new EditorGUILayout.HorizontalScope())
            {
                EditorGUILayout.LabelField(title, EditorStyles.boldLabel);
                GUILayout.FlexibleSpace();
                if (GUILayout.Button(T("SelectAll"), GUILayout.Width(50)))
                {
                    if (isModel)
                        foreach (var m in _modelMeshes) m.Selected = true;
                    else
                        foreach (var m in _mqoObjects) m.Selected = true;
                }
                if (GUILayout.Button(T("SelectNone"), GUILayout.Width(50)))
                {
                    if (isModel)
                        foreach (var m in _modelMeshes) m.Selected = false;
                    else
                        foreach (var m in _mqoObjects) m.Selected = false;
                }
            }
        }

        private void DrawModelList()
        {
            MeshEntry toRemove = null;
            foreach (var entry in _modelMeshes)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    entry.Selected = EditorGUILayout.Toggle(entry.Selected, GUILayout.Width(20));

                    // PMXは展開後の値しか得られないので常にExpandedVertexCount
                    int verts = entry.ExpandedVertexCount;
                    string label = $"{entry.Name} ({verts})";

                    if (entry.IsBakedMirror)
                    {
                        GUI.color = new Color(0.7f, 0.7f, 1f);
                    }
                    EditorGUILayout.LabelField(label);
                    GUI.color = Color.white;

                    // 削除ボタン
                    if (GUILayout.Button("×", GUILayout.Width(20)))
                    {
                        toRemove = entry;
                    }
                }
            }

            // ループ外で削除
            if (toRemove != null)
            {
                _modelMeshes.Remove(toRemove);
            }
        }

        private void DrawMQOList()
        {
            foreach (var entry in _mqoObjects)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    entry.Selected = EditorGUILayout.Toggle(entry.Selected, GUILayout.Width(20));
                    // MQO側は展開後頂点数を表示（モデル側と比較するため）
                    EditorGUILayout.LabelField($"{entry.Name} ({entry.ExpandedVertexCount})");
                }
            }
        }

        // ================================================================
        // エクスポートセクション
        // ================================================================

        private void DrawExportSection()
        {
            int modelCount = _modelMeshes.Count(m => m.Selected);
            int mqoCount = _mqoObjects.Count(m => m.Selected);

            // PMXは展開後の値しか得られないので常にExpandedVertexCount
            int modelVerts = _modelMeshes.Where(m => m.Selected)
                .Sum(m => m.ExpandedVertexCount);
            int mqoVerts = _mqoObjects.Where(m => m.Selected).Sum(m => m.ExpandedVertexCount);

            EditorGUILayout.LabelField(T("Selection", modelCount, mqoCount) + $"  Verts: {modelVerts} → {mqoVerts}");

            bool vertexMatch = modelVerts == mqoVerts;
            bool canExport = modelCount > 0 && mqoCount > 0 && _mqoDocument != null;

            if (!vertexMatch && canExport)
            {
                EditorGUILayout.HelpBox(T("VertexMismatch", "Model", modelVerts, "MQO", mqoVerts), MessageType.Warning);
            }

            using (new EditorGUI.DisabledScope(!canExport))
            {
                if (GUILayout.Button(T("Export"), GUILayout.Height(30)))
                {
                    ExecuteExport();
                }
            }

            if (!string.IsNullOrEmpty(_lastResult))
            {
                EditorGUILayout.HelpBox(_lastResult, MessageType.Info);
            }
        }

        // ================================================================
        // データ構築
        // ================================================================

        private void BuildModelList()
        {
            _modelMeshes.Clear();

            var model = Model;
            if (model == null) return;

            var drawables = model.DrawableMeshes;
            if (drawables == null) return;

            for (int i = 0; i < drawables.Count; i++)
            {
                var entry = drawables[i];
                var ctx = entry.Context;
                if (ctx?.MeshObject == null) continue;

                var mo = ctx.MeshObject;
                if (mo.VertexCount == 0) continue;

                // ベイクミラーフラグでスキップ
                if (_skipBakedMirror && ctx.IsBakedMirror) continue;

                var isolated = PMXMQOTransferPanel.GetIsolatedVertices(mo);
                int expandedCount = PMXMQOTransferPanel.CalculateExpandedVertexCount(mo, isolated);

                _modelMeshes.Add(new MeshEntry
                {
                    Selected = false,
                    Index = i,
                    Name = ctx.Name,
                    VertexCount = mo.VertexCount,
                    ExpandedVertexCount = expandedCount,
                    IsBakedMirror = ctx.IsBakedMirror,
                    Context = ctx,
                    IsolatedVertices = isolated
                });
            }
        }

        private void BuildMQOList()
        {
            _mqoObjects.Clear();

            if (_mqoImportResult == null || !_mqoImportResult.Success) return;

            // インポート結果のMeshContextsを使用
            foreach (var meshContext in _mqoImportResult.MeshContexts)
            {
                var mo = meshContext.MeshObject;
                if (mo == null || mo.VertexCount == 0) continue;

                var isolated = PMXMQOTransferPanel.GetIsolatedVertices(mo);
                int expandedCount = PMXMQOTransferPanel.CalculateExpandedVertexCount(mo, isolated);

                _mqoObjects.Add(new MQOEntry
                {
                    Selected = false,
                    Index = _mqoObjects.Count,
                    Name = meshContext.Name,
                    VertexCount = mo.VertexCount,
                    ExpandedVertexCount = expandedCount,
                    MeshContext = meshContext
                });
            }
        }

        // ================================================================
        // MQO読み込みと自動照合
        // ================================================================

        private void LoadMQOAndMatch()
        {
            LoadMQO();
            BuildMQOList();

            // モデルリストも（再）構築
            if (_modelMeshes.Count == 0)
            {
                BuildModelList();
            }

            if (_mqoDocument != null)
            {
                AutoMatch();
            }
            Repaint();
        }

        private void LoadMQO()
        {
            if (string.IsNullOrEmpty(_mqoFilePath) || !File.Exists(_mqoFilePath))
            {
                _mqoDocument = null;
                _mqoImportResult = null;
                return;
            }

            try
            {
                // MQODocumentをパース
                _mqoDocument = MQOParser.ParseFile(_mqoFilePath);

                // MQOをインポートしてMeshContextを取得（展開後頂点数計算用）
                var settings = new MQOImportSettings
                {
                    ImportMaterials = false,
                    SkipHiddenObjects = true,
                    MergeObjects = false,
                    FlipZ = _flipZ,
                    FlipUV_V = false,
                    BakeMirror = false
                };
                _mqoImportResult = MQOImporter.ImportFile(_mqoFilePath, settings);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[MQOPartialExport] Load failed: {ex.Message}");
                _mqoDocument = null;
                _mqoImportResult = null;
            }
        }

        private void AutoMatch()
        {
            // PMXは展開後の値しか得られないので、展開後頂点数で照合
            // 頂点がないオブジェクトは照合しない
            foreach (var model in _modelMeshes)
            {
                model.Selected = false;
                if (model.ExpandedVertexCount == 0) continue;
                
                // 同じ展開後頂点数のMQOオブジェクトを探す
                var match = _mqoObjects.FirstOrDefault(m => 
                    m.ExpandedVertexCount == model.ExpandedVertexCount && 
                    m.ExpandedVertexCount > 0);
                if (match != null)
                {
                    model.Selected = true;
                    match.Selected = true;
                }
            }
        }

        // ================================================================
        // エクスポート実行
        // ================================================================

        private void ExecuteExport()
        {
            try
            {
                string defaultName = Path.GetFileNameWithoutExtension(_mqoFilePath) + "_partial.mqo";
                string savePath = EditorUtility.SaveFilePanel("Save MQO", Path.GetDirectoryName(_mqoFilePath), defaultName, "mqo");

                if (string.IsNullOrEmpty(savePath))
                    return;

                // 選択されたものをリスト化
                var selectedModels = _modelMeshes.Where(m => m.Selected).ToList();
                var selectedMQOs = _mqoObjects.Where(m => m.Selected).ToList();

                int transferred = 0;
                int modelVertexOffset = 0;  // モデル側の頂点オフセット

                // MQOオブジェクトごとに転送
                foreach (var mqoEntry in selectedMQOs)
                {
                    int count = TransferToMQO(mqoEntry, selectedModels, ref modelVertexOffset);
                    transferred += count;
                }

                // 保存
                Utility.MQOWriter.WriteToFile(_mqoDocument, savePath);

                // 結果表示
                int totalModelVerts = _modelMeshes.Where(m => m.Selected)
                    .Sum(m => m.ExpandedVertexCount);
                int totalMqoVerts = _mqoObjects.Where(m => m.Selected).Sum(m => m.ExpandedVertexCount);

                _lastResult = T("ExportSuccess", $"{transferred} vertices → {Path.GetFileName(savePath)}");
                if (totalModelVerts != totalMqoVerts)
                {
                    _lastResult += $"\n(Model:{totalModelVerts} ≠ MQO:{totalMqoVerts})";
                }

                // リロード
                LoadMQO();
                BuildMQOList();
            }
            catch (Exception ex)
            {
                _lastResult = T("ExportFailed", ex.Message);
                Debug.LogError($"[MQOPartialExport] {ex.Message}\n{ex.StackTrace}");
            }

            Repaint();
        }

        /// <summary>
        /// MQO側のMeshContextを基準に、モデル側の頂点を転送
        /// PMXMQOTransferPanel.TransferPMXToMQOと同じアプローチ
        /// WriteBackFlags対応: Position, UV, BoneWeight
        /// </summary>
        private int TransferToMQO(MQOEntry mqoEntry, List<MeshEntry> modelMeshes, ref int modelVertexOffset)
        {
            var mqoMeshContext = mqoEntry.MeshContext;
            var mqoMo = mqoMeshContext?.MeshObject;
            if (mqoMo == null) return 0;

            // MQODocument側のオブジェクトを名前で検索
            var mqoDocObj = _mqoDocument.Objects.FirstOrDefault(o => o.Name == mqoEntry.Name);
            if (mqoDocObj == null) return 0;

            // WriteBackFlagsを構築
            WriteBackFlags flags = WriteBackFlags.None;
            if (_writeBackPosition) flags |= WriteBackFlags.Position;
            if (_writeBackUV) flags |= WriteBackFlags.UV;
            if (_writeBackBoneWeight) flags |= WriteBackFlags.BoneWeight;

            int transferred = 0;
            int startOffset = modelVertexOffset;

            // MQO側のMeshContextの頂点を走査
            for (int vIdx = 0; vIdx < mqoMo.VertexCount; vIdx++)
            {
                var mqoVertex = mqoMo.Vertices[vIdx];
                int uvCount = mqoVertex.UVs.Count > 0 ? mqoVertex.UVs.Count : 1;

                // Position更新
                if (_writeBackPosition)
                {
                    Vector3? newPos = GetModelVertexPosition(modelMeshes, modelVertexOffset);

                    if (newPos.HasValue)
                    {
                        Vector3 pos = newPos.Value;

                        // 座標変換: Model → MQO
                        if (_flipZ) pos.z = -pos.z;
                        pos *= _scale;

                        // MeshContextとMQODocument両方を更新
                        mqoVertex.Position = pos;
                        if (vIdx < mqoDocObj.Vertices.Count)
                        {
                            mqoDocObj.Vertices[vIdx].Position = pos;
                        }

                        transferred++;
                    }
                }

                // UV展開分だけモデル側インデックスを進める
                modelVertexOffset += uvCount;
            }

            // UV更新（WriteBack APIを使用）
            if (_writeBackUV)
            {
                WriteBackUVsToMQO(mqoEntry, modelMeshes, startOffset, mqoDocObj);
            }

            // BoneWeight更新（WriteBack APIを使用）
            if (_writeBackBoneWeight)
            {
                WriteBackBoneWeightsToMQO(mqoEntry, modelMeshes, startOffset, mqoDocObj);
            }

            return transferred;
        }

        /// <summary>
        /// UVを面のUVs配列に書き戻す
        /// MQO側の面のUVIndicesを使って、対応する展開後インデックスを特定
        /// </summary>
        private void WriteBackUVsToMQO(MQOEntry mqoEntry, List<MeshEntry> modelMeshes, int startOffset, MQOObject mqoDocObj)
        {
            var mqoMo = mqoEntry.MeshContext?.MeshObject;
            if (mqoMo == null) return;

            // MQO側の頂点インデックス→展開後オフセット開始位置のマッピングを構築
            var vertexToExpandedStart = new Dictionary<int, int>();
            int expandedIdx = 0;
            for (int vIdx = 0; vIdx < mqoMo.VertexCount; vIdx++)
            {
                vertexToExpandedStart[vIdx] = expandedIdx;
                int uvCount = mqoMo.Vertices[vIdx].UVs.Count > 0 ? mqoMo.Vertices[vIdx].UVs.Count : 1;
                expandedIdx += uvCount;
            }

            // MQODocument側の面とMeshContext側の面を並行して走査
            int mqoFaceIdx = 0;
            foreach (var mqoDocFace in mqoDocObj.Faces)
            {
                if (mqoDocFace.IsSpecialFace) continue;
                if (mqoDocFace.VertexIndices == null) continue;

                // 対応するMeshContext側の面を探す（特殊面をスキップしながら）
                Face meshFace = null;
                while (mqoFaceIdx < mqoMo.FaceCount)
                {
                    meshFace = mqoMo.Faces[mqoFaceIdx];
                    mqoFaceIdx++;
                    // MeshContextには特殊面がないはずだが念のため
                    if (meshFace.VertexIndices.Count >= 3) break;
                    meshFace = null;
                }

                if (meshFace == null) continue;

                // 面のUVs配列を確保
                if (mqoDocFace.UVs == null || mqoDocFace.UVs.Length != mqoDocFace.VertexIndices.Length)
                {
                    mqoDocFace.UVs = new Vector2[mqoDocFace.VertexIndices.Length];
                }

                for (int i = 0; i < mqoDocFace.VertexIndices.Length && i < meshFace.VertexIndices.Count; i++)
                {
                    int vIdx = mqoDocFace.VertexIndices[i];
                    if (!vertexToExpandedStart.TryGetValue(vIdx, out int localExpStart)) continue;

                    // UVIndicesからUVスロット番号を取得
                    int uvSlot = (i < meshFace.UVIndices.Count) ? meshFace.UVIndices[i] : 0;

                    // 展開後インデックス = 頂点の展開開始位置 + UVスロット番号
                    int globalOffset = startOffset + localExpStart + uvSlot;
                    Vector2? uv = GetModelVertexUV(modelMeshes, globalOffset);
                    if (uv.HasValue)
                    {
                        mqoDocFace.UVs[i] = uv.Value;
                    }
                }
            }
        }

        /// <summary>
        /// ボーンウェイトを特殊面として書き戻す（既存削除→新規追加）
        /// </summary>
        private void WriteBackBoneWeightsToMQO(MQOEntry mqoEntry, List<MeshEntry> modelMeshes, int startOffset, MQOObject mqoDocObj)
        {
            var mqoMo = mqoEntry.MeshContext?.MeshObject;
            if (mqoMo == null) return;

            // 既存の特殊面を削除（頂点ID特殊面とボーンウェイト特殊面）
            mqoDocObj.Faces.RemoveAll(f => f.IsSpecialFace);

            // 頂点ID特殊面とボーンウェイト特殊面を再追加
            int localOffset = 0;
            for (int vIdx = 0; vIdx < mqoMo.VertexCount && vIdx < mqoDocObj.Vertices.Count; vIdx++)
            {
                var mqoVertex = mqoMo.Vertices[vIdx];
                int uvCount = mqoVertex.UVs.Count > 0 ? mqoVertex.UVs.Count : 1;

                int globalOffset = startOffset + localOffset;

                // モデル側から頂点情報を取得
                var vertexInfo = GetModelVertexInfo(modelMeshes, globalOffset);
                if (vertexInfo != null)
                {
                    // 頂点ID特殊面
                    if (vertexInfo.Id != -1)
                    {
                        mqoDocObj.Faces.Add(
                            VertexIdHelper.CreateSpecialFaceForVertexId(vIdx, vertexInfo.Id, 0));
                    }

                    // ボーンウェイト特殊面
                    if (vertexInfo.HasBoneWeight)
                    {
                        var boneWeightData = VertexIdHelper.BoneWeightData.FromUnityBoneWeight(vertexInfo.BoneWeight.Value);
                        mqoDocObj.Faces.Add(
                            VertexIdHelper.CreateSpecialFaceForBoneWeight(vIdx, boneWeightData, false, 0));
                    }
                }

                localOffset += uvCount;
            }
        }

        /// <summary>
        /// モデル側の指定オフセットからUVを取得
        /// PMXは展開後の値しか得られないので展開後インデックスで処理
        /// </summary>
        private Vector2? GetModelVertexUV(List<MeshEntry> modelMeshes, int offset)
        {
            int currentOffset = 0;

            foreach (var model in modelMeshes)
            {
                var mo = model.Context?.MeshObject;
                if (mo == null) continue;

                int meshVertCount = model.ExpandedVertexCount;

                if (offset < currentOffset + meshVertCount)
                {
                    int localIdx = offset - currentOffset;

                    int expandedIdx = 0;
                    for (int vIdx = 0; vIdx < mo.VertexCount; vIdx++)
                    {
                        var v = mo.Vertices[vIdx];
                        int uvCount = v.UVs.Count > 0 ? v.UVs.Count : 1;

                        if (localIdx < expandedIdx + uvCount)
                        {
                            int uvSlot = localIdx - expandedIdx;
                            return uvSlot < v.UVs.Count ? v.UVs[uvSlot] : (v.UVs.Count > 0 ? v.UVs[0] : Vector2.zero);
                        }
                        expandedIdx += uvCount;
                    }

                    return null;
                }

                currentOffset += meshVertCount;
            }

            return null;
        }

        /// <summary>
        /// モデル側の指定オフセットから頂点情報を取得
        /// PMXは展開後の値しか得られないので展開後インデックスで処理
        /// </summary>
        private Vertex GetModelVertexInfo(List<MeshEntry> modelMeshes, int offset)
        {
            int currentOffset = 0;

            foreach (var model in modelMeshes)
            {
                var mo = model.Context?.MeshObject;
                if (mo == null) continue;

                int meshVertCount = model.ExpandedVertexCount;

                if (offset < currentOffset + meshVertCount)
                {
                    int localIdx = offset - currentOffset;

                    int expandedIdx = 0;
                    for (int vIdx = 0; vIdx < mo.VertexCount; vIdx++)
                    {
                        var v = mo.Vertices[vIdx];
                        int uvCount = v.UVs.Count > 0 ? v.UVs.Count : 1;

                        if (localIdx < expandedIdx + uvCount)
                        {
                            return v;
                        }
                        expandedIdx += uvCount;
                    }

                    return null;
                }

                currentOffset += meshVertCount;
            }

            return null;
        }

        /// <summary>
        /// モデル側の指定オフセットから頂点位置を取得
        /// PMXは展開後の値しか得られないので展開後インデックスで処理
        /// </summary>
        private Vector3? GetModelVertexPosition(List<MeshEntry> modelMeshes, int offset)
        {
            int currentOffset = 0;

            foreach (var model in modelMeshes)
            {
                var mo = model.Context?.MeshObject;
                if (mo == null) continue;

                int meshVertCount = model.ExpandedVertexCount;

                if (offset < currentOffset + meshVertCount)
                {
                    int localIdx = offset - currentOffset;

                    int expandedIdx = 0;
                    for (int vIdx = 0; vIdx < mo.VertexCount; vIdx++)
                    {
                        var v = mo.Vertices[vIdx];
                        int uvCount = v.UVs.Count > 0 ? v.UVs.Count : 1;

                        if (localIdx < expandedIdx + uvCount)
                        {
                            return v.Position;
                        }
                        expandedIdx += uvCount;
                    }

                    return null;
                }

                currentOffset += meshVertCount;
            }

            return null;
        }

        // ================================================================
        // ユーティリティ
        // ================================================================

        private void HandleDropOnRect(Rect rect, string ext, Action<string> onDrop)
        {
            var evt = Event.current;
            if (!rect.Contains(evt.mousePosition)) return;

            if (evt.type == EventType.DragUpdated)
            {
                if (DragAndDrop.paths.Length > 0 && Path.GetExtension(DragAndDrop.paths[0]).ToLower() == ext)
                {
                    DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                    evt.Use();
                }
            }
            else if (evt.type == EventType.DragPerform)
            {
                if (DragAndDrop.paths.Length > 0 && Path.GetExtension(DragAndDrop.paths[0]).ToLower() == ext)
                {
                    DragAndDrop.AcceptDrag();
                    onDrop(DragAndDrop.paths[0]);
                    evt.Use();
                }
            }
        }
    }
}