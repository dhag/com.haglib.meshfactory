#pragma kernel ClearBuffers
#pragma kernel ComputeScreenPositions
#pragma kernel ComputeFaceVisibility
#pragma kernel ComputeLineVisibility

struct LineSegment { int v1; int v2; int faceIndex; int lineType; };

StructuredBuffer<float3> _PositionBuffer;
StructuredBuffer<LineSegment> _LineBuffer;
ByteAddressBuffer _FaceVertexIndexBuffer;
ByteAddressBuffer _FaceVertexOffsetBuffer;
ByteAddressBuffer _FaceVertexCountBuffer;

RWStructuredBuffer<float4> _ScreenPositionBuffer;
RWStructuredBuffer<float> _VertexVisibilityBuffer;
RWStructuredBuffer<float> _FaceVisibilityBuffer;
RWStructuredBuffer<float> _LineVisibilityBuffer;

float4x4 _MATRIX_MVP;
float4 _ScreenParams;    // windowSize.x, windowSize.y, 0, 0
float4 _PreviewRect;     // x, y, width, height
uint _VertexCount;
uint _FaceCount;
uint _LineCount;

[numthreads(64, 1, 1)]
void ClearBuffers(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index < _VertexCount) { _VertexVisibilityBuffer[index] = 0.0; _ScreenPositionBuffer[index] = float4(-10000, -10000, 0, 0); }
    if (index < _FaceCount) { _FaceVisibilityBuffer[index] = 0.0; }
    if (index < _LineCount) { _LineVisibilityBuffer[index] = 0.0; }
}

[numthreads(64, 1, 1)]
void ComputeScreenPositions(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= _VertexCount) return;
    float3 worldPos = _PositionBuffer[index];
    float4 clipPos = mul(_MATRIX_MVP, float4(worldPos, 1.0));
    if (clipPos.w > 0.0001)
    {
        float2 ndc = clipPos.xy / clipPos.w;
        // previewRect内のローカル座標 + previewRectのオフセット = ウィンドウ座標
        float screenX = _PreviewRect.x + (ndc.x * 0.5 + 0.5) * _PreviewRect.z;
        float screenY = _PreviewRect.y + (1.0 - (ndc.y * 0.5 + 0.5)) * _PreviewRect.w;
        _ScreenPositionBuffer[index] = float4(screenX, screenY, clipPos.z / clipPos.w, 1.0);
    }
    else { _ScreenPositionBuffer[index] = float4(-10000, -10000, -10000, 0.0); }
}

bool IsClockwise(float2 vertices[16], int numVertices)
{
    float signedArea = 0;
    for (int i = 0; i < numVertices; i++)
    {
        int next = (i + 1) % numVertices;
        signedArea += (vertices[next].x - vertices[i].x) * (vertices[next].y + vertices[i].y);
    }
    // GUI座標系はY軸下向きなので符号を反転
    return signedArea < 0;
}

[numthreads(64, 1, 1)]
void ComputeFaceVisibility(uint3 id : SV_DispatchThreadID)
{
    uint faceIndex = id.x;
    if (faceIndex >= _FaceCount) return;
    int vertexCount = asint(_FaceVertexCountBuffer.Load(faceIndex * 4));
    int offset = asint(_FaceVertexOffsetBuffer.Load(faceIndex * 4));
    if (vertexCount <= 2)
    {
        _FaceVisibilityBuffer[faceIndex] = 1.0;
        for (int j = 0; j < vertexCount; j++)
        {
            int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + j) * 4));
            _VertexVisibilityBuffer[vIdx] = 1.0;
        }
        return;
    }
    float2 screenVerts[16];
    bool allValid = true;
    for (int i = 0; i < vertexCount && i < 16; i++)
    {
        int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + i) * 4));
        float4 screenPos = _ScreenPositionBuffer[vIdx];
        if (screenPos.w < 0.5) { allValid = false; break; }
        screenVerts[i] = screenPos.xy;
    }
    if (!allValid) { _FaceVisibilityBuffer[faceIndex] = 0.0; return; }
    bool isFrontFacing = IsClockwise(screenVerts, vertexCount);
    _FaceVisibilityBuffer[faceIndex] = isFrontFacing ? 1.0 : 0.0;
    if (isFrontFacing)
    {
        for (int k = 0; k < vertexCount; k++)
        {
            int vIdx = asint(_FaceVertexIndexBuffer.Load((offset + k) * 4));
            _VertexVisibilityBuffer[vIdx] = 1.0;
        }
    }
}

[numthreads(64, 1, 1)]
void ComputeLineVisibility(uint3 id : SV_DispatchThreadID)
{
    uint lineIndex = id.x;
    if (lineIndex >= _LineCount) return;
    LineSegment seg = _LineBuffer[lineIndex];
    if (seg.lineType == 1) { _LineVisibilityBuffer[lineIndex] = 1.0; return; }
    _LineVisibilityBuffer[lineIndex] = _FaceVisibilityBuffer[seg.faceIndex];
}
